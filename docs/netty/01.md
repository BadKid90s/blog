---
title: 几种线程模型
date: 2020-12-02
tags:
- Netty
categories:
- Netty
---


## 几种线程模型 

## 传统阻塞I/O服务模型 

传统的 BIO 服务端编程采用“每线程每连接”的处理模型，弊端很明显，就是面对大量的客户端并发连接时，服务端的资源压力很大；并且线程的利用率很低，如果当前线程没有数据可读，它会阻塞在 read 操作上。

![image-20211223155848216](https://gitee.com/BadKid90s/imageshack/blob/other/image-20211223155848216.png)

### 特点 

1.采用阻塞IO模式获取输入的数据 

2.每个连接都需要单独的线程完成数据的输入，业务的处理，数据的返回 

### 问题
1.并发数很大的情况下，就会创建大量线程，占用很大的系统资源

2.连接创建后，如果当前线程没有数据可读，该线程就会阻塞在read操作，造成线程资源浪费。


## Reactor模型 

![image-20211223155944015](https://gitee.com/BadKid90s/imageshack/blob/other/image-20211223155944015.png)

### 根据Reactor的数量和处理资源的线程数量的不同又分为

- 单Reactor单线程
- 单Reactor多线程
- 主从Reactor多线程

**netty线程模型基于主从Reactor多线程做了改进!**



### 针对传统阻塞I/O服务模型2个缺点的解决方案



#### 1.基于I/O复用模型 

多个连接共用一个阻塞对象，应用程序只需要在一个阻塞对象等待，无需阻塞等待所有连接。
当某个连接有新的数据可以处理时，操作系统通知应用程序，线程从阻塞状态返回，开始进行业务处理。

#### 2.基于线程池复用资源

不必为每个连接创建线程，将连接完成后的业务处理任务分配给线程进行处理，一个线程可以处理多个连接的业务。



### I/O复用结合线程池，就是Reactor模型的基本设计思想
1. 通过一个或多个输入请求，同时传递给服务处理器的模式（基于事件驱动）。
2. 服务器端程序处理传入的多个请求，并将他们分派到相应的处理线程。 （Reactor模式也称Dispatcher模式）。
3. Reactor模式使用I/O复用监听事件，收到事件后分发给某个线程，这就是网络高并发处理关键。



## Reactor模型核心组成

#### Reactor
Reactor是在一个单独的线程中运行，负责监听和分发事件，分发给适当的处理程序来对I/O事件做出回应。

#### Handlers
处理程序执行I/O事件要完成的实际事件，类似与客户想要与之交谈的公司中的实际官员。

Reactor通过调度适当的Handlers来响应I/O事件，处理程序执行非阻塞操作。
