(window.webpackJsonp=window.webpackJsonp||[]).push([[17],{685:function(e,o,t){e.exports=t.p+"assets/img/image-20211223161636778.0fdb042c.png"},686:function(e,o,t){e.exports=t.p+"assets/img/image-20211223161816509.a26b3f8d.png"},687:function(e,o,t){e.exports=t.p+"assets/img/image-20211223162206238.35dd7c60.png"},793:function(e,o,t){"use strict";t.r(o);var r=t(5),v=Object(r.a)({},(function(){var e=this,o=e.$createElement,r=e._self._c||o;return r("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[r("h1",{attrs:{id:"netty模型"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#netty模型"}},[e._v("#")]),e._v(" Netty模型")]),e._v(" "),r("h2",{attrs:{id:"简单版"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#简单版"}},[e._v("#")]),e._v(" 简单版")]),e._v(" "),r("p",[e._v("Netty主要基于主从Reactors多线程模型做了一定的改进，其中主从Reactor多线程模型有多个Reactor。")]),e._v(" "),r("p",[r("img",{attrs:{src:t(685),alt:"image-20211223161636778"}})]),e._v(" "),r("h3",{attrs:{id:"说明"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#说明"}},[e._v("#")]),e._v(" 说明")]),e._v(" "),r("ol",[r("li",[e._v("BossGroup 线程维护 Selector，ServerSocketChannel 注册到这个 Selector 上，只关注连接建立请求事件（相当于主 Reactor）。")]),e._v(" "),r("li",[e._v("当接收到来自客户端的连接建立请求事件的时候，通过 ServerSocketChannel.accept 方法获得对应的 SocketChannel，并封装成 NioSocketChannel 注册到 WorkerGroup 线程中的 Selector，每个 Selector 运行在一个线程中（相当于从 Reactor）。")]),e._v(" "),r("li",[e._v("当 WorkerGroup 线程中的 Selector 监听到自己感兴趣的 IO 事件后，就调用 Handler 进行处理。")])]),e._v(" "),r("h2",{attrs:{id:"进阶版"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#进阶版"}},[e._v("#")]),e._v(" 进阶版")]),e._v(" "),r("p",[r("img",{attrs:{src:t(686),alt:"image-20211223161816509"}})]),e._v(" "),r("h3",{attrs:{id:"说明-2"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#说明-2"}},[e._v("#")]),e._v(" 说明")]),e._v(" "),r("ol",[r("li",[r("p",[e._v("有两组线程池：BossGroup 和 WorkerGroup，BossGroup 中的线程（可以有多个，图中只画了一个）专门负责和客户端建立连接，WorkerGroup 中的线程专门负责处理连接上的读写。")])]),e._v(" "),r("li",[r("p",[e._v("BossGroup 和 WorkerGroup 含有多个不断循环的执行事件处理的线程，每个线程都包含一个 Selector，用于监听注册在其上的 Channel。")])]),e._v(" "),r("li",[r("p",[e._v("每个 BossGroup 中的线程循环执行以下三个步骤：")]),e._v(" "),r("ul",[r("li",[e._v("3.1）轮训注册在其上的 ServerSocketChannel 的 accept 事件（OP_ACCEPT 事件）")]),e._v(" "),r("li",[e._v("3.2）处理 accept 事件，与客户端建立连接，生成一个 NioSocketChannel，并将其注册到 WorkerGroup 中某个线程上的 Selector 上。")]),e._v(" "),r("li",[e._v("3.3）再去以此循环处理任务队列中的下一个事件")])])]),e._v(" "),r("li",[r("p",[e._v("每个 WorkerGroup 中的线程循环执行以下三个步骤：")]),e._v(" "),r("ul",[r("li",[e._v("4.1）轮训注册在其上的 NioSocketChannel 的 read/write 事件（OP_READ/OP_WRITE 事件）。")]),e._v(" "),r("li",[e._v("4.2）在对应的 NioSocketChannel 上处理 read/write 事件。")]),e._v(" "),r("li",[e._v("4.3）再去以此循环处理任务队列中的下一个事件。")])])])]),e._v(" "),r("h2",{attrs:{id:"终极版"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#终极版"}},[e._v("#")]),e._v(" 终极版")]),e._v(" "),r("p",[r("img",{attrs:{src:t(687),alt:"image-20211223162206238"}})]),e._v(" "),r("h3",{attrs:{id:"说明-3"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#说明-3"}},[e._v("#")]),e._v(" 说明")]),e._v(" "),r("ol",[r("li",[r("p",[e._v("Netty 抽象出两组线程池：BossGroup 和 WorkerGroup，也可以叫做 BossNioEventLoopGroup 和 WorkerNioEventLoopGroup。每个线程池中都有NioEventLoop 线程。BossGroup 中的线程专门负责和客户端建立连接，WorkerGroup 中的线程专门负责处理连接上的读写。BossGroup 和 WorkerGroup 的类型都是 NioEventLoopGroup。")])]),e._v(" "),r("li",[r("p",[e._v("NioEventLoopGroup 相当于一个事件循环组，这个组中含有多个事件循环，每个事件循环就是一个 NioEventLoop。")])]),e._v(" "),r("li",[r("p",[e._v("NioEventLoop 表示一个不断循环的执行事件处理的线程，每个 NioEventLoop 都包含一个 Selector，用于监听注册在其上的 Socket 网络连接（Channel）。")])]),e._v(" "),r("li",[r("p",[e._v("NioEventLoopGroup 可以含有多个线程，即可以含有多个 NioEventLoop。")])]),e._v(" "),r("li",[r("p",[e._v("每个 BossNioEventLoop 中循环执行以下三个步骤：")]),e._v(" "),r("ul",[r("li",[e._v("5.1）"),r("strong",[e._v("select")]),e._v("：轮训注册在其上的 ServerSocketChannel 的 accept 事件（OP_ACCEPT 事件）。")]),e._v(" "),r("li",[e._v("5.2）"),r("strong",[e._v("processSelectedKeys")]),e._v("：处理 accept 事件，与客户端建立连接，生成一个 NioSocketChannel，并将其注册到某个 WorkerNioEventLoop 上的 Selector 上。")]),e._v(" "),r("li",[e._v("5.3）"),r("strong",[e._v("runAllTasks")]),e._v("：再去以此循环处理任务队列中的其他任务")])])]),e._v(" "),r("li",[r("p",[e._v("每个 WorkerNioEventLoop 中循环执行以下三个步骤：")]),e._v(" "),r("ul",[r("li",[r("p",[e._v("6.1）"),r("strong",[e._v("select")]),e._v("：轮训注册在其上的 NioSocketChannel 的 read/write 事件（OP_READ/OP_WRITE 事件）。")])]),e._v(" "),r("li",[r("p",[e._v("6.2）"),r("strong",[e._v("processSelectedKeys")]),e._v("：在对应的 NioSocketChannel 上处理 read/write 事件。")])]),e._v(" "),r("li",[r("p",[e._v("6.3）"),r("strong",[e._v("runAllTasks")]),e._v("：再去以此循环处理任务队列中的其他任务。")])])])]),e._v(" "),r("li",[r("p",[e._v("在以上两个"),r("strong",[e._v("processSelectedKeys")]),e._v("步骤中，会使用 Pipeline（管道），Pipeline 中引用了 Channel，即通过 Pipeline 可以获取到对应的 Channel，Pipeline 中维护了很多的处理器（拦截处理器、过滤处理器、自定义处理器等）。这里暂时不详细展开讲解 Pipeline。")])])])])}),[],!1,null,null,null);o.default=v.exports}}]);