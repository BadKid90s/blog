(window.webpackJsonp=window.webpackJsonp||[]).push([[20],{683:function(a,t,r){a.exports=r.p+"assets/img/image-20211223155848216.3b47138c.png"},684:function(a,t,r){a.exports=r.p+"assets/img/image-20211223155944015.2848bc0a.png"},792:function(a,t,r){"use strict";r.r(t);var s=r(5),e=Object(s.a)({},(function(){var a=this,t=a.$createElement,s=a._self._c||t;return s("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[s("h2",{attrs:{id:"几种线程模型"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#几种线程模型"}},[a._v("#")]),a._v(" 几种线程模型")]),a._v(" "),s("h2",{attrs:{id:"传统阻塞i-o服务模型"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#传统阻塞i-o服务模型"}},[a._v("#")]),a._v(" 传统阻塞I/O服务模型")]),a._v(" "),s("p",[a._v("传统的 BIO 服务端编程采用“每线程每连接”的处理模型，弊端很明显，就是面对大量的客户端并发连接时，服务端的资源压力很大；并且线程的利用率很低，如果当前线程没有数据可读，它会阻塞在 read 操作上。")]),a._v(" "),s("p",[s("img",{attrs:{src:r(683),alt:"image-20211223155848216"}})]),a._v(" "),s("h3",{attrs:{id:"特点"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#特点"}},[a._v("#")]),a._v(" 特点")]),a._v(" "),s("p",[a._v("1.采用阻塞IO模式获取输入的数据")]),a._v(" "),s("p",[a._v("2.每个连接都需要单独的线程完成数据的输入，业务的处理，数据的返回")]),a._v(" "),s("h3",{attrs:{id:"问题"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#问题"}},[a._v("#")]),a._v(" 问题")]),a._v(" "),s("p",[a._v("1.并发数很大的情况下，就会创建大量线程，占用很大的系统资源")]),a._v(" "),s("p",[a._v("2.连接创建后，如果当前线程没有数据可读，该线程就会阻塞在read操作，造成线程资源浪费。")]),a._v(" "),s("h2",{attrs:{id:"reactor模型"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#reactor模型"}},[a._v("#")]),a._v(" Reactor模型")]),a._v(" "),s("p",[s("img",{attrs:{src:r(684),alt:"image-20211223155944015"}})]),a._v(" "),s("h3",{attrs:{id:"根据reactor的数量和处理资源的线程数量的不同又分为"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#根据reactor的数量和处理资源的线程数量的不同又分为"}},[a._v("#")]),a._v(" 根据Reactor的数量和处理资源的线程数量的不同又分为")]),a._v(" "),s("ul",[s("li",[a._v("单Reactor单线程")]),a._v(" "),s("li",[a._v("单Reactor多线程")]),a._v(" "),s("li",[a._v("主从Reactor多线程")])]),a._v(" "),s("p",[s("strong",[a._v("netty线程模型基于主从Reactor多线程做了改进!")])]),a._v(" "),s("h3",{attrs:{id:"针对传统阻塞i-o服务模型2个缺点的解决方案"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#针对传统阻塞i-o服务模型2个缺点的解决方案"}},[a._v("#")]),a._v(" 针对传统阻塞I/O服务模型2个缺点的解决方案")]),a._v(" "),s("h4",{attrs:{id:"_1-基于i-o复用模型"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-基于i-o复用模型"}},[a._v("#")]),a._v(" 1.基于I/O复用模型")]),a._v(" "),s("p",[a._v("多个连接共用一个阻塞对象，应用程序只需要在一个阻塞对象等待，无需阻塞等待所有连接。\n当某个连接有新的数据可以处理时，操作系统通知应用程序，线程从阻塞状态返回，开始进行业务处理。")]),a._v(" "),s("h4",{attrs:{id:"_2-基于线程池复用资源"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-基于线程池复用资源"}},[a._v("#")]),a._v(" 2.基于线程池复用资源")]),a._v(" "),s("p",[a._v("不必为每个连接创建线程，将连接完成后的业务处理任务分配给线程进行处理，一个线程可以处理多个连接的业务。")]),a._v(" "),s("h3",{attrs:{id:"i-o复用结合线程池-就是reactor模型的基本设计思想"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#i-o复用结合线程池-就是reactor模型的基本设计思想"}},[a._v("#")]),a._v(" I/O复用结合线程池，就是Reactor模型的基本设计思想")]),a._v(" "),s("ol",[s("li",[a._v("通过一个或多个输入请求，同时传递给服务处理器的模式（基于事件驱动）。")]),a._v(" "),s("li",[a._v("服务器端程序处理传入的多个请求，并将他们分派到相应的处理线程。 （Reactor模式也称Dispatcher模式）。")]),a._v(" "),s("li",[a._v("Reactor模式使用I/O复用监听事件，收到事件后分发给某个线程，这就是网络高并发处理关键。")])]),a._v(" "),s("h2",{attrs:{id:"reactor模型核心组成"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#reactor模型核心组成"}},[a._v("#")]),a._v(" Reactor模型核心组成")]),a._v(" "),s("h4",{attrs:{id:"reactor"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#reactor"}},[a._v("#")]),a._v(" Reactor")]),a._v(" "),s("p",[a._v("Reactor是在一个单独的线程中运行，负责监听和分发事件，分发给适当的处理程序来对I/O事件做出回应。")]),a._v(" "),s("h4",{attrs:{id:"handlers"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#handlers"}},[a._v("#")]),a._v(" Handlers")]),a._v(" "),s("p",[a._v("处理程序执行I/O事件要完成的实际事件，类似与客户想要与之交谈的公司中的实际官员。")]),a._v(" "),s("p",[a._v("Reactor通过调度适当的Handlers来响应I/O事件，处理程序执行非阻塞操作。")])])}),[],!1,null,null,null);t.default=e.exports}}]);