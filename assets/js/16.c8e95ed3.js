(window.webpackJsonp=window.webpackJsonp||[]).push([[16],{688:function(a,t,r){a.exports=r.p+"assets/img/image-20211223160059792.918d16f3.png"},689:function(a,t,r){a.exports=r.p+"assets/img/image-20211223160122949.e8f88058.png"},690:function(a,t,r){a.exports=r.p+"assets/img/image-20211223160209220.2301ce7b.png"},794:function(a,t,r){"use strict";r.r(t);var e=r(5),v=Object(e.a)({},(function(){var a=this,t=a.$createElement,e=a._self._c||t;return e("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[e("h2",{attrs:{id:"几种reactor模型"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#几种reactor模型"}},[a._v("#")]),a._v(" 几种Reactor模型")]),a._v(" "),e("h2",{attrs:{id:"单reactor单线程"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#单reactor单线程"}},[a._v("#")]),a._v(" 单Reactor单线程")]),a._v(" "),e("p",[e("img",{attrs:{src:r(688),alt:"image-20211223160059792"}})]),a._v(" "),e("h3",{attrs:{id:"说明"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#说明"}},[a._v("#")]),a._v(" 说明")]),a._v(" "),e("ol",[e("li",[a._v("select是前面I/O复用模型介绍的标准网络编程API,可以实现应用程序通过一个阻塞对象监听多路连接请求。")]),a._v(" "),e("li",[a._v("Reactor 对象通过Select监听客户端请求事件，收到事件后通过Dispatch进行分发。")]),a._v(" "),e("li",[a._v("如果是建立连接请求事件，则是有Acceptor通过Accept处理连接请求，然后创建一个Handler对象处理连接完成后的后续业务处理。")]),a._v(" "),e("li",[a._v("如果不是建立连接事件，则Reactor会分发调用连接对于的Handler来响应。")]),a._v(" "),e("li",[a._v("Handler会完成Read--\x3e业务处理--\x3eSend的完整业务流程。")])]),a._v(" "),e("h3",{attrs:{id:"优点"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#优点"}},[a._v("#")]),a._v(" 优点")]),a._v(" "),e("p",[a._v("模型简单，没有多线程、进程通信、竞争的问题，全部都在一个线程中完成。")]),a._v(" "),e("h3",{attrs:{id:"缺点"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#缺点"}},[a._v("#")]),a._v(" 缺点")]),a._v(" "),e("ol",[e("li",[a._v("性能问题，只有一个线程，无法发挥多核CPU的性能.Handler在处理某个连接上的业务时，整个进程无法处理其他连接事件，很容易导致性能瓶颈。")]),a._v(" "),e("li",[a._v("可靠性问题，线程意外终止，或者进入死循环，会导致整个系统通讯模块不可用，不能接收和处理外部消息，造成节点故障。")])]),a._v(" "),e("h3",{attrs:{id:"使用场景"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#使用场景"}},[a._v("#")]),a._v(" 使用场景")]),a._v(" "),e("p",[a._v("客户端的数量有限，业务处理非常快速，比如Redis在业务处理的事间复杂度O(1)的情况。")]),a._v(" "),e("h2",{attrs:{id:"单reactor多线程"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#单reactor多线程"}},[a._v("#")]),a._v(" 单Reactor多线程")]),a._v(" "),e("p",[e("img",{attrs:{src:r(689),alt:"image-20211223160122949"}})]),a._v(" "),e("h3",{attrs:{id:"说明-2"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#说明-2"}},[a._v("#")]),a._v(" 说明")]),a._v(" "),e("ol",[e("li",[a._v("Reactor对象通过Select监听客户端请求，收到请求后，通过Dispatch进行分发。")]),a._v(" "),e("li",[a._v("如果是建立连接请求事件，则是有Acceptor通过Accept处理连接请求，然后创建一个Handler对象处理连接完成后的后续业务处理。")]),a._v(" "),e("li",[a._v("如果不是连接请求，则Reactor分发调用连接对于的Handler来处理。")]),a._v(" "),e("li",[a._v("Hander只负责响应事件，不做具体的业务处理。通过Read读取数据后，会分发给后面的worker线程池的某个线程处理业务。")]),a._v(" "),e("li",[a._v("worker线程池会分配独立的线程完成真正的业务，并将结构返回给Handler。")]),a._v(" "),e("li",[a._v("Handler收到响应后，通过Send将结果返回给客户端。")])]),a._v(" "),e("h3",{attrs:{id:"优点-2"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#优点-2"}},[a._v("#")]),a._v(" 优点")]),a._v(" "),e("p",[a._v("可以充分利用多核CPU的处理能力。")]),a._v(" "),e("h3",{attrs:{id:"缺点-2"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#缺点-2"}},[a._v("#")]),a._v(" 缺点")]),a._v(" "),e("p",[a._v("多线程数据共享和访问比较复杂，Reactor处理所有的事件的监听和响应都在单线程运行。在高并发的情况下容易出现性能瓶颈。")]),a._v(" "),e("h2",{attrs:{id:"主从reactor多线程"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#主从reactor多线程"}},[a._v("#")]),a._v(" 主从Reactor多线程")]),a._v(" "),e("p",[e("img",{attrs:{src:r(690),alt:"image-20211223160209220"}})]),a._v(" "),e("h3",{attrs:{id:"说明-3"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#说明-3"}},[a._v("#")]),a._v(" 说明")]),a._v(" "),e("ol",[e("li",[a._v("Reactor主线程（MainReactor）对象通过Select监听客户端请求，收到请求后，如果是建立连接请求事件，则是有Acceptor通过Accept处理连接请求")]),a._v(" "),e("li",[a._v("当Acceptor处理连接事件后，MainReactor将连接分配给SubReactor对象。")]),a._v(" "),e("li",[a._v("SubReactor对象将连接加入到连接队列进行监听，并创建Handler进行各种事件的处理。")]),a._v(" "),e("li",[a._v("当有事件发生时，SubReactor就会调用对于的Handler处理。")]),a._v(" "),e("li",[a._v("Hander只负责响应事件，不做具体的业务处理。通过Read读取数据后，会分发给后面的worker线程池的某个线程处理业务。")]),a._v(" "),e("li",[a._v("worker线程池会分配独立的线程完成真正的业务，并将结构返回给Handler。")]),a._v(" "),e("li",[a._v("Handler收到响应后，通过Send将结果返回给客户端。")]),a._v(" "),e("li",[a._v("一个Reactor主线程可以对应多个SubReactor子线程。")])]),a._v(" "),e("h3",{attrs:{id:"优点-3"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#优点-3"}},[a._v("#")]),a._v(" 优点")]),a._v(" "),e("ol",[e("li",[a._v("父线程和子线程的数据交互简单职责明确，父线程只需要接收新连接，子线程完成后续的业务处理。")]),a._v(" "),e("li",[a._v("父线程和子线程的数据交互简单，Reactor主线程只需要把新来连接传给子线程，子线程无需返回数据。")])]),a._v(" "),e("h3",{attrs:{id:"缺点-3"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#缺点-3"}},[a._v("#")]),a._v(" 缺点")]),a._v(" "),e("p",[a._v("编程复杂度高。")]),a._v(" "),e("h2",{attrs:{id:"reactor模型的优点"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#reactor模型的优点"}},[a._v("#")]),a._v(" Reactor模型的优点")]),a._v(" "),e("ol",[e("li",[a._v("响应快，不必为单个同步时间所阻塞，虽然Reactor本身依然是同步的。")]),a._v(" "),e("li",[a._v("可以最大程度的避免复杂的多线程及同步问题，并且避免了多线程/进程的切换开销。")]),a._v(" "),e("li",[a._v("扩展性好，可以方便的通过增加Reactor实例个数。来充分利用CPU资源。")]),a._v(" "),e("li",[a._v("复用性好，Reactor模型本身与具体事件处理逻辑无关，具有很高的复用性。")])])])}),[],!1,null,null,null);t.default=v.exports}}]);